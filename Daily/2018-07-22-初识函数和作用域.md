# 初始函数和作用域

```js
function foo(n) {
	// 函数逻辑
    // 零到多行代码组成的代码段集合
}
```

Truly Question：

当你尝试用一句话解释**函数**概念时，会发现结果将会是一个又臭又长的句子，例如：一个函数是将为了实现一个特定功能而有序的组织到一起的一个代码段集合，目的为了这个功能能被重复利用。于是我才意识到，一些教科书中对数学、物理等概念的讲述都是通过短句组合而成的，多么符合人性（这里面不符合人性的是，教科书没有讲清楚为什么要如此这般的去组织概念）

**函数：**

- 从实现上看，函数是一个块状结构，包含了
  - 一个关键字 `function` 
  - 一个命名变量 `foo`
  - 一个块级作用域标识 `{}`
  - 零到多行代码组成的代码段集合
- 可选的结构还可以报考：
  - 零个或多个的入参变量
  - 返回值关键字 `function`

从长句去解释到短句的组合拳，其实已经是一个逻辑概念的跃迁了。但是对一个概念的理解应该不止于此，因为截至当前，我们仅仅知道了：一些名词而已。

我们需要站高一个角度，从编译器的视角去看，函数的每个组成部分都在做什么。

**关键字 `function`**

编译器遇到关键字，就会按照既定规则做一些列的处理。遇到 `function` 我们可以想象会把 `function` 下的ATS 子节点都作为函数内容去解析。

- 尝试去定位 `()` 符号，并将小括号前的表达式声明称一个==``变量``==，变量将指向函数开始的位置（内存地址）；
- 将 `{}` 里的内容依次写到指定的内存位置；

Truly Question：

1. 思考下有入参和返回值的情况编译器的完整处理过程？
2. 如果没有命名呢，会发生什么有意思的事情？

**命名变量**

函数名称有意思的地方在于，他就像点头之交的朋友，看起来很熟，但其实你们并不相知。

最重要的概念在于：函数的名称其实也是一个**变量**。这个变量就像一个指针，指向了一个内存位置，这个位置向下依次整整齐齐排列了一堆代码，这些代码协同合作，实现同一个目标，这就是函数最朴质的意义了。

有名字的函数是*具名函数*， 当然就对应一类没名字的函数：**匿名函数**。

Truly Question：

1. 为什么需要匿名函数？
2. 编译器怎么看匿名函数，有没有内存泄露的问题？

**块级作用域标识 `{}`**

块级作用域一直是 JavaScript 给程序员挖坑数量前几的神级存在，重要的原因在于：常规看来 JavaScript 是没有块级作用域的。

```js
var foo = function() {
	console.log(a);
}
var a = 3;
foo();// 3
```

函数内部可以访问外部变量，这似乎是人尽皆知的很显然的事情。但熟悉我们的朋友都知道，这里又是一个值得深挖的地方。

**作用域** 难以进入你的下意识层面的原因在于：他是由两部分组合而成的一个抽象概念。

一个变量集合和一个如何索引这些变量的规则，这两个合成了**作用域**这个概念。

例如：

- 当我们提到*字典*，一个满是文字的物理实体跃然脑海；
- 当我们提到*如何根据偏旁部首找寻我们需要的文字*，这是一个使用字典的动作，我们姑且抽象为*对字典的索引*；

当我们把一个实体+一个动作合起来，就称之为：使用字典。

这是我们今天第二个逻辑跃迁点。

对实体的抽象很容易理解，对动作的抽象也容易理解，将这类结合就显得有点**抽象**了。其实只是我们没有==有意识==的去使用，去变得熟悉，而日常生活当中处处是这类实体+动作的抽象。例如：人。人这个概念你总不能仅理解为一个驱壳，其实他还有动作，更甚至他还有灵魂。

回到作用域的概念。当我们再提到作用域的时候，脑海里面应该能浮现出来：这是一个概念，描述的是一个怎么根据名称寻找变量的概念。（从内部找，还是从外部找，这些变量比如都存于某处，关键的是规则。